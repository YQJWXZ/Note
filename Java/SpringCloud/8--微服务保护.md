# 微服务保护

1. 雪崩问题
> 微服务调用链路中的某个服务故障，引起整个链路中的所有微服务不可用，这就是雪崩

解决雪崩问题的常见方式：
* 超时处理  ``设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待``
* 舱壁模式  ``限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，也叫线程隔离``
* 熔断降级  ``由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切需求``
* 流量控制  ``限制业务访问的QPS，避免服务因流量的突增而故障``

## 1. Sentinel

### 1.1 微服务整合Sentinel
* 引入依赖
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency> 
```
* 配置控制台地址
```yml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
```
* 访问微服务的任意端点，触发sentinel监控

### 1.2 限流规则
 
1. 簇点链路  ``就是项目内的调用链路，链路中被监控的每个接口就是一个资源``
> 默认情况下sentinel会监控SpringMVC的每一个端点(Endpoint)，因此SpringMVC的每一个端点就是调用链路中的一个资源

2. 流控规则
* 流控模式  ``统计访问某个资源的所有请求，判断是否超过QPS阈值``
    * 直接  ``当前资源限流``
    * 关联  ``a，b两个资源，b触发阈值，对a进行限流，给谁限流就给谁加规则``
    * 链路  ``统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流``
```
满足下面条件可以使用关联模式：
1. 两个有竞争关系的资源
2. 一个优先级较高，一个优先级较低
```

```
1. Sentinel默认只标记Controller中的方法为资源，如果要标记其他方法，需要利用@SentinelResource注解
2. Sentinel默认会将Controller方法做context整合，导致链路模式的流控失败，需要修改application.yml，添加配置：
spring:
    cloud:
        sentinel:
            web-context-unify: false  # 关闭context整合
```

* 流控效果
    * 快速失败  ``默认的处理方式，达到阈值后心得请求会被立即拒绝并抛出FlowException异常``
    * warm up  ``预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种阈值会动态变化，从一个较小值逐渐增加到最大阈值``
    * 排队等待  ``让所有的请求按照先后次序派对执行，两个请求的间隔不能小于指定时长``

```
warm up 请求阈值初始值是threshold/coldFactor，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3
```

```
当请求超过QPS阈值时，快速失败和warm up会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。
后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝
```

* 热点参数限流  ``分别统计参数值相同的请求，判断是否超过QPS阈值``

> 热点参数限流对默认的SpringMVC资源无效，所以需要加SentinelResource注解

### 1.3 隔离和降级

1. FeignClient整合Sentinel
* 修改Service中的application.yml文件，开启Feign的Sentinel功能
```yaml
feign:
  sentinel:
    enabled: true  # 开启Feign的Sentinel功能
```
* 给FeignClient编写失败后的降级逻辑
  * 方式一：FallbackClass，无法对远程调用的异常做处理
  * 方式二：FallbackFactory，可以对远程调用的异常做处理
```java
// 步骤一：定义类，实现FallbackFactory
@Slf4j
public class UserClientFallbackFactory implements FallbackFactory<UserClients>{
    @Override
    public userClient create(Throwable throwable){
        // 创建UserClient接口实现类，实现其中的方法，编写失败降级的处理逻辑
      return new userClient(){
          @Override
        public User findById(long id){
              // 纪录异常信息
            log.error("查询用户失败",throwable);
            // 根据业务需求返回默认的数据，空用户
            return new User();
          }
      };
    }
}

// 步骤二：在Configuration类中将UserClientFallbackFactory注册为一个Bean
@Bean
public UserClientFallbackFactory userClientFallback(){
    return new UserClientFallbackFactory();
}

// 步骤三：在UserClient接口中使用UserClientFallbackFactory
@FeignClient(value="userservice",fallbackFactory=UserClientFallbackFactory.calss)
public interface UserClient{
    @GetMapping("/user/{id}")
    User findById(@PathVariable("id") Long id);
}
```
2. 线程隔离(舱壁模式)

线程隔离的两种实现方式：
* 线程池隔离
  * 支持主动超时
  * 支持异步调用
  * 线程的额外开销比较大
* 信号量隔离(Sentinel默认采用)
  * 轻量级，无额外开销
  * 不支持注定超时、异步调用

3. 熔断降级

> 由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务，即拦截访问该服务的一切请求。而当服务恢复时，断路器会放行访问该服务的请求

1. 熔断策略
* 慢调用  ``业务的响应时长大于指定时长的请求``
* 异常比例、异常数  ``统计单位时长内异常调用的比例(次数)，超过阈值则熔断``


### 1.4 授权规则

> 授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式

Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的
```java
public interface RequestOriginParse{
    String parseOrigin(HttpServletRequest request);
}
```
1.在gateway服务中，利用网关的过滤器添加名为gateway的origin头
```yaml
spring:
  cloud:
    gateway:
      default-filters:
        - AddRequestHeader=origin,gateway  # 添加名为origin的请求头，值为gateway
```
2. 尝试从request中获取一个名为origin的请求头，作为origin的值
```java
@Component
public class HeaderOriginParser implements RequestOriginParser {
    @Override
  public String parseOrigin(HttpServletRequest request){
        String origin = request.getHeader("origin");
        if(StringUtils.isEmpty(origin)){
            return "blank";
        }
        return origin;
    }
}
```

3. 自定义异常结果 
  如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口
```java
public interface BolckExceptionHandler {
    void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;
}
```
而BlockException包含很多个子类
* FlowException  ``限流异常``
* ParamFlowException  ``热点参数限流的异常``
* DegradeException  ``降级异常``
* AuthorityException  ``授权规则异常``
* SystemBlockException  ``系统规则异常``

```java
@Component
public class SentinelExceptionHandler implements BlockExceptionHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {
        String msg = "未知异常";
        int status = 429;

        if (e instanceof FlowException) {
            msg = "请求被限流了";
        } else if (e instanceof ParamFlowException) {
            msg = "请求被热点参数限流";
        } else if (e instanceof DegradeException) {
            msg = "请求被降级了";
        } else if (e instanceof AuthorityException) {
            msg = "没有权限访问";
            status = 401;
        }

        response.setContentType("application/json;charset=utf-8");
        response.setStatus(status);
        response.getWriter().println("{\"msg\": " + msg + ", \"status\": " + status + "}");
    }
}
```

### 1.5 规则持久化

1. 规则管理模式
* 原始模式  ``Sentinel的默认模式，将规则保存在内存，重启服务会丢失``
* pull模式  ``控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中  定时轮询，更新本地规则``
* push模式  ``控制台将配置规则推送到远程配置中心 例如Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新``


2. 实现push模式
