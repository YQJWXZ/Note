# 远程调用

## 1. RestTemplate

1. 注册RestTemplate(Application中)
```java
@MapperScan("cn.itcast.order.mapper")
@SpringBootApplication
public class OrderApplication{
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class,args);
    }
    
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```
2. 服务远程调用RestTemplate(Service中)
```java
    @Autowired
    private RestTemplate restTemplate;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.findById(orderId);
        
        // 2.利用RestTemplate发起http请求，查询用户
        // 2.1.url路径 （硬编码）
        String url = "http://userservice/user/" + order.getUserId();
        // 2.2.发送http请求，实现远程调用
        User user = restTemplate.getForObject(url, User.class);
        
        // 3.封装user到Order
        order.setUser(user);
        // 4.返回
        return order;
    }
```
## 2. Feign远程调用

1. RestTemplate存在的问题：
* 代码可读性差，编程体验不统一
* 参数复杂URL难以维护

### 2.1 定义和使用Feign客户端

1. 导依赖
```xml
<dedpendency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>dpring-cloud-starter-openfeign</artifactId>
</dedpendency>
```

2. 在service的启动类添加注解开启Feign的功能
```java
@EnableFeignClients
@MapperScan("com.xiaoyi.order.mapper")
@SpringBootApplication
public class OrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class,args);
    }
}
```

3. 编写Feign客户端
```java
@FeignClient("userservice")  // 服务名称
public interface UserClient {
    
    @GetMapping("/user/{id}")  // 请求方式GET  请求路径/user/{id}
    User findById(@PathVariable("id") Long id);  // 返回值类型User  请求参数Long id
}
```

### 2.2 Feign自定义配置
1. Feign运行自定义配置来覆盖默认配置：
* *feign.Logger.Level* 修改日志级别  ``NONE、BASIC、HEADERS、FULL``
* feign.codec.Decoder 响应结果的解析器
* feign.codec.Encoder 请求参数编码
* feign.Contract  支持的注解格式，默认是SpringMVC的注解
* feign.Retryer  失败重试机制，默认是没有，不过会使用Ribbon的重试

#### 修改日志级别：
1. 方式一：配置文件方式
* 全局生效
```yml
feign:
  client:
    config:
      default:  # 这里用default就是全局配置，如果写服务名称，则是针对某个微服务的配置
        loggerLevel: FULL  # 日志级别
```
* 局部生效
```yml
feign:
  client:
    config:
      userservice:  # 这里用default就是全局配置，如果写服务名称，则是针对某个微服务的配置
        loggerLevel: FULL  # 日志级别
```

2. 方式二：java代码方式，首先需要声明一个Bean:
```java
public class FeignClientConfiguration {
    @Bean
    public Logger.Level feignLogLevel(){
        return logger.Level.BASIC;
    }
}
```
* 全局配置，把它放到@EnableFeignClients这个注解中
> @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)
* 局部配置，把它放到@FeignClient这个注解中
> @FeignClient(value = "userservice", configuration = FeignClientConfiguration.class)

### 2.3 Feign性能优化

> 使用连接池代替默认的URLConnnection
> 
> 日志级别，最好用basic或none

1. Feign底层的客户端实现：
* URLConnection: 默认实现，不支持连接池
* Apache HttpClient: 支持连接池
* OKHttp: 支持连接池

2. 性能优化--连接池配置
* 引入依赖
```xml
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-httpClient</artifactId>
</dependency>
```

* 配置连接池
```yml
feign:
  client:
    config:
      default:
        loggerLevel: BASIC
  httpclient:
    enabled: true  # 开启feign对HttpClient的支持
    max-connections: 200  # 最大连接数
    max-connections-pre-route: 50  # 单个请求路径的最大连接数
```

### 2.4 Feign的最佳实践

1. 方式一：继承  ``给消费者的FeignClient和提供者的controller定义统一的父接口作为标准``
> 一般情况下不推荐服务端与客户端共享接口，会造成紧耦合，并且父接口参数列表中的映射不会被继承
```java
    // 父接口
    public interface UserAPI{
    @GetMapping("/user/{id}")
    User findById(@PathVariable("id") Long id);
}

    // 服务端
    @RestController
    public class UserController implements UserAPI{
        public User findById(@PathVariable("id") Long id){
            // .. 实现业务
        }
    }
    
    // 客户端
    @FeignClient(value = "userservice")
    public interface UserClient extends UserAPI{}
```

2. 方式二：抽取  ``将FeignClient抽取为独立模块，并把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有的消费者使用``
* 创建一个module，命名为feign-api，然后引用feign的starter依赖
* 将service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中
* 在service中导入feign-api的依赖
* 修改service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包
* 重启测试

```java
    // 当定义的FeignClient不再SpringBootApplication的扫描包范围时，这些FeignClient是无法使用，有两种方式解决：

    // 方式一：指定FeignClient所在包
    @EnableFeignClients(basePackages = "com.xiaoyi.feign.clients")

    // 方式二：指定FeignClient字节码
    @EnableFeignClients(clients = {UserClient.class})
```