# 分布式事务

事务的ACID操作：
* 原子性
* 一致性
* 隔离性
* 持久性

分布式事务：在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。

## 1. 理论基础

### 1.1 CAP定理

分布式系统有三个指标
* Consistency(一致性)
* Availability(可用性)
* Partition tolerance(分区容错性)
分布式系统无法同时满足这三个指标，这个结论就叫做CAP定理

### 1.2 BASE理论

BASE理论是对CAP的一种解决思路，包含三个思想：
* Basically Available(基本可用)  ``分布式系统在出现故障时，允许损失部分可用性，即保证核心可用``
* Soft State(软状态)  ``在一定时间内，允许出现中间状态，比如临时的不一致状态``
* Eventually Consistent(最终一致性)  ``虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致``

## 2. Seata

### 2.1 Seata架构

Seata事务管理中有三个重要的角色：
* TC(Transaction Coordinator)  事务协调者  ``维护全局和分支业务的状态，协调全局事务提交或回滚``
* TM(Transaction Manager)  事务管理器  ``定义全局事务的范围、开始全局事务、提交或回滚全局事务``
* RM(Resource Manager)  资源管理器  ``管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚``

### 2.2 部署TC服务

### 2.3 微服务集成Seata

1.引入依赖
```xml
<dependency>
<groupId>com.alibaba.cloud</groupId>
<artifactId>spring-cloud-starter-alibaba-seata</artifactId>
<exclusions>
<!--版本较低，1.3.0，因此排除-->
<exclusion>
<artifactId>seata-spring-boot-starter</artifactId>
<groupId>io.seata</groupId>
</exclusion>
</exclusions>
</dependency>
<!--seata starter 采用1.4.2版本-->
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>${seata.version}</version>
</dependency>
```

2. 然后配置application.yml，让微服务通过注册中心找到seata
> namespace -> group -> serviceName -> cluster

```yml
seata:
  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址
    # 参考tc服务自己的registry.conf中的配置
    type: nacos
    nacos: # tc
      server-addr: 127.0.0.1:8848
      namespace: ""
      group: DEFAULT_GROUP
      application: seata-tc-server # tc服务在nacos中的服务名称
      username: nacos
      password: nacos
  tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称
  service:
    vgroup-mapping: # 事务组与TC服务cluster的映射关系
      seata-demo: SH
```

### 2.4 模式

#### 2.4.1 XA模式
优点：
* 事务的强一致性，满足ACID原则
* 常用数据库都支持，实现简单，并且没有代码侵入

缺点：
* 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差
* 依赖关系型数据库实现事务

1. 实现XA模式
* 修改application.yml文件，开启XA模式
```yaml
seata:
  data-source-proxy-mode: XA
```
* 给发起全局事务的入口方法添加@GlobalTransactional注解
```java
@Override
@GlobalTransactional
public Long create(Order order){
    // 创建订单
    orderMapper.insert(order);
    // 扣余额....
    // 扣减库存...
        return order.getId();
        }
```
* 重启服务并测试

#### 2.4.2 AT模式
> 注册分支事务 -> 记录快照 -> 执行业务SQL -> 提交、报告事务状态 -> 是否可以提交(是：删除快照，否：读取快照，恢复数据)

1. AT模式与XA模式的区别：
* XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源
* XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚
* XA模式强一致，AT模式最终一致


优点：
* 一阶段完成直接提交事务，释放数据库资源，性能比较好
* 利用全局锁实现读写隔离
* 没有代码侵入，框架自动完成回滚和提交

缺点：
* 两阶段之间属于软状态，属于最终一致
* 框架的快照功能会影响性能，但比XA模式要好很多

2. AT模式的脏写问题

全局锁(实现数据隔离)：由TC纪录当前正在操作某行数据的事务，该事务持有全局锁，具备执行权

更新前快照、更新后快照

3. 实现AT模式
* 准备两张表(lock_table导入到TC服务关联的数据库, undo_log表导入到微服务关联的数据库)
* 修改application.yml文件，将实务模式修改为AT模式
```yaml
seata:
  data-source-proxy-mode: AT 
```
* 重启服务并测试

#### 2.4.3 TCC模式
1. TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：
* Try：资源的检测和预留
* Confirm: 完成资源操作业务；要求Try成功Confirm一定要能成功
* Cancel：预留资源释放，可以理解为try的反向操作

优点：
* 一阶段完成直接提交事务，释放数据库资源，性能好
* 相比AT模式，无需生成快照，无需使用全局锁，性能最强
* 不依赖数据库事务，而是依赖补偿操作，可以用于非实物型数据库 

缺点：
* 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦
* 软状态，事务是最终一致
* 需要考虑Confirm和Cancel的失败情况，做好幂等处理

2. 空回滚
当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。
在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚

3. 业务悬挂
对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂

4. 声明TCC接口
```java
// TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明
@LocalTCC
public interface TCCService{
    /**
     * Try逻辑，@TwoPahseBusinessAction中的name属性要与当前方法名一致，用于指定try逻辑对应的方法
     */
    @TwoPhaseBusinessAction(name="prepare", commitMethod="confirm",rollbackMethod="cancel")
    void prepare(@BusinessActionContextParameter(paramName="param") String param);
    /**
     * 二阶段confirm确认方法，可以另命名，但要保证与commitMethod一致
     * 
     * @param context 上下文，可以传递try方法的参数
     * @return boolean 执行是否成功
     */
    boolean confirm(BusinessActionContext context);
    /**
     * 二阶段回滚方法，要保证与rollbackMethod一致
     */
    boolean cancel (businessActionContext context);
}
```
5. 实现TCC接口的实现类
```java
@Service
@Slf4j
public class AccountTCCServiceImpl implements AccountTCCService {

    @Autowired
    private AccountMapper accountMapper;
    @Autowired
    private AccountFreezeMapper freezeMapper;

    @Override
    @Transactional
    public void deduct(String userId, int money) {
        // 0.获取事务id
        String xid = RootContext.getXID();
        // 1. 判断freeze中是否有冻结纪录，如果有，一定是CANCLE执行过，我要拒绝业务(业务悬挂)
        AccountFreeze oldFreeze = freezeMapper.selectById(xid);
        if(oldFreeze!=null){
            // CANCEL执行过，我要拒绝业务
            return;
        }
        // 1.扣减可用余额
        accountMapper.deduct(userId, money);
        // 2.记录冻结金额，事务状态
        AccountFreeze freeze = new AccountFreeze();
        freeze.setUserId(userId);
        freeze.setFreezeMoney(money);
        freeze.setState(AccountFreeze.State.TRY);
        freeze.setXid(xid);
        freezeMapper.insert(freeze);
    }

    @Override
    public boolean confirm(BusinessActionContext ctx) {
        // 1.获取事务id
        String xid = ctx.getXid();
        // 2.根据id删除冻结记录
        int count = freezeMapper.deleteById(xid);
        return count == 1;
    }

    @Override
    public boolean cancel(BusinessActionContext ctx) {
        // 0.查询冻结记录
        String xid = ctx.getXid();
        String userId=ctx.getActionContext("userId").toString();
        AccountFreeze freeze = freezeMapper.selectById(xid);
        // 1. 空回滚的判断，判断freeze是否为null，为null 则证明try没有执行，需要空回滚
        if(freeze==null){
            // 证明try没执行，需要空回滚
            freeze.setUserId(userId);
            freeze.setFreezeMoney(0);
            freeze.setState(AccountFreeze.State.CANCEL);
            freeze.setXid(xid);
            freezeMapper.insert(freeze);
            return true;
        }
        // 2. 幂等判断
        if(freeze.getState()==AccountFreeze.State.CANCEL){
            // 已经处理过一次CANCEL了，无需重复处理
            return true;
        }
        // 1.恢复可用余额
        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());
        // 2.将冻结金额清零，状态改为CANCEL
        freeze.setFreezeMoney(0);
        freeze.setState(AccountFreeze.State.CANCEL);
        int count = freezeMapper.updateById(freeze);
        return count == 1;
    }
}
```
#### 2.4.4 SAGA模式

1. Saga模式是SEATA提供的长事务解决方案，也分为两个阶段：
* 一阶段：直接提交本地事务
* 二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚

优点：
* 事务参与者可以基于事件驱动实现异步调用，吞吐高
* 一阶段直接提交事务，无锁，性能好
* 不用编写TCC中的三个阶段，实现简单

缺点：
* 软状态持续时间不定，时效性差
* 没有锁，没有事务隔离，会有脏写