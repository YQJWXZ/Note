# 1. 函数式接口

## 1. 函数式接口概述
函数式接口： ``有且仅有一个抽象方法的接口``

``
Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口
``

``
只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利的进行推导
``

检测一个接口是不是函数式接口：``@FunctionalInterface``

## 1.2 函数式接口作为方法的参数
如果方法的参数是一个函数式 接口，可以用Lambda表达式作为参数传递
```java
public class RunnableDemo {
    /*
        定义一个类(RunnableDemo),在类中提供两个方法
                一个方法是：startThread(Runnable r)  方法参数Runnable是一个函数式接口
                一个方法是主方法，在主方法中调用startThread方法
     */
    public static void main(String[] args) {
        // 在主方法中调用startThread方法
        startThread(() -> System.out.println(Thread.currentThread().getName() + "线程启动了"));
    }
    private static void startThread(Runnable r) {
        new Thread(r).start();
    }
}
```

## 1.3 函数式接口作为方法的返回值
如果方法的返回值是一个函数式接口，可以用Lambda表达式作为结果返回
```java
public class ComparatorDemo {
    /*
         定义一个类(ComparatorDemo)，在类中提供两个方法“
                一个方法是： Comparator<String> getComparator()   方法返回值Comparator是一个函数式接口
                一个方法是主方法： 在主方法中调用getComparator方法

     */
    public static void main(String[] args) {
        // 定义集合，存储字符串元素
        ArrayList<String> array=new ArrayList<>();
        array.add("cccc");
        array.add("aa");
        array.add("b");
        array.add("ddd");
        System.out.println("排序前："+array);

//        Collections.sort(array);
        Collections.sort(array,getComparator());
        System.out.println("排序后："+array);
    }
    private static Comparator<String> getComparator(){
        return (o1,o2)->o1.length()-o2.length();
    }
}
```

## 1.4 常用的函数式接口
1. Supplier接口  ``生产型接口``
```java
public class SupplierDemo {
    public static void main(String[] args) {
        String s=getString(()->"林青霞");
        System.out.println(s);

        Integer i=getInteger(()->30);
        System.out.println(i);
    }
    // 定义一个方法，返回一个整数数据
    private static Integer getInteger(Supplier<Integer> sup){
        return sup.get();
    }
    // 定义一个方法，返回一个字符串数据
    private static String getString(Supplier<String> sup){
        return sup.get();
    }
}
```

2. Consumer接口  ``消费型接口``
```java
public class ConsumerDemo {
    public static void main(String[] args) {
        operatorString("林青霞",s -> System.out.println(s));
//      operatorString("林青霞",System.out::println);
        operatorString("林青霞",s-> System.out.println(new StringBuilder(s).reverse().toString()));

        System.out.println("----------");
        
        operatorString("林青霞",s-> System.out.println(s),s-> System.out.println(new StringBuilder(s).reverse().toString()));
   
    }
    // 定义一个方法，用不同的方式消费同一个字符串数据两次
    private static void operatorString(String name,Consumer<String> con1,Consumer<String> con2){
        con1.andThen(con2).accept(name);
    }
    // 定义一个方法，消费一个字符串数据
    private static void operatorString(String name, Consumer<String> con){
        con.accept(name);
    }
}
```
3. Predicate接口 ``布尔值函数``
Predicate<T>接口通常用于判断参数是否满足指定的条件
```java
public class PredicateDemo01 {
    public static void main(String[] args) {

        boolean b1 = checkString("hello", s->s.length() > 8);
        System.out.println(b1);

        boolean b2 = checkString("helloworld", s -> s.length() > 8);
        System.out.println(b2);

        boolean b3=checkString("hello",s -> s.length()>8,s->s.length()<15);
        System.out.println(b3);

        boolean b4 = checkString("helloworld", s -> s.length() > 8, s -> s.length() < 15);
        System.out.println(b4);
    }

    // 同一个字符串给出两个不同的判断条件，最后把这两个判断的结果做逻辑与运算的结果作为最终的结果
    private static boolean checkString(String s,Predicate<String> pre1,Predicate<String> pre2){
        return  pre1.or(pre2).test(s);
    }
    // 判断给定的字符串是否满足要求
    private static boolean checkString(String s, Predicate<String> pre){
          return pre.negate().test(s);     // 逻辑非
    }
}
```
4. Function接口
Function<T,R>接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值
```java
public class FunctionDemo {
    public static void main(String[] args) {
        convert("100",s -> Integer.parseInt(s));
        convert("100",Integer::parseInt);

        convert(100,i->String.valueOf(i+566));
        convert("100",s->Integer.parseInt(s),i->String.valueOf(i+566));
    }
    // 定义一个方法，把一个字符串转换为int类型，在控制台输出
    private static void convert(String s, Function<String,Integer> fun){
        int i= fun.apply(s);
        System.out.println(i);
    }
    // 定义一个方法，把一个 int类型的数据加上一个整数之后，转为字符串在控制台输出
    private static void convert(int i,Function<Integer,String> fun){
        String s= fun.apply(i);
        System.out.println(s);
    }
    // 定义一个方法，把一个字符串转换成int类型,把int类型的数据加上一个整数后，转为字符串在控制台上输出
    private static void convert(String s,Function<String,Integer> fun1,Function<Integer,String > fun2){
        String ss = fun1.andThen(fun2).apply(s);
        System.out.println(ss);
    }
}
```