# 1. 类加载
## 1.1 类加载
程序使用某个类，该类未加载到内存中 ->（JVM） 类的加载，类的连接，类的初始化

1. 类的加载
* 就是指将class文件读入内存，并为之创建一个java.lang.Class对象
* 任何类被使用时，系统都会为之建立一个java.lang.Class对象

2. 类的连接
* 验证阶段  ``检验被加载的类是否有正确的内部结构，并和其他类协调一致``
* 准备阶段  ``负责为类的类变量分配内存，并设置默认初始化值``
* 解析阶段  ``将类的二进制数据中的符号引用替换为直接引用``

3. 类的初始化
主要就是对类变量进行初始化

类的初始化步骤：
* 类还未被加载或连接 --> 先加载并连接
* 该类的**直接父类**未被初始化  -->  先初始化直接父类
* 类中有初始化语句  -->  依次执行这些初始化语句

类的初始化时机：
* 创建类的实例
* 调用类的类方法
* 访问类或接口的类变量，或者为该类变量赋值
* 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
* 初始化某个类的子类
* 直接使用java.exe命令来运行某个主类

## 1.2 类加载器
类加载器的作用：
* 负责将.class文件加载到内存中，并为之生成java.lang.Class对象

JVM的类加载机制：
* 全盘负责
* 父类委托
* 缓存机制

ClassLoader: 负责加载类的对象

Java运行时具有以下内置类加载器：
* Bootstrap class loader  ``虚拟机的内置类加载器，通常为null，没有父``
* Platform class loader ``平台类加载器``
* System class loader  ``应用程序类加载器``
继承关系： System(子类) --> Platform(父类) --> Platform(祖先类 )
```java
public class ClassLoaderDemo {
    public static void main(String[] args) {
        ClassLoader system = ClassLoader.getSystemClassLoader();
        System.out.println(system); // AppClassLoader@78308db1

        ClassLoader parent = system.getParent();
        System.out.println(parent); // PlatformClassLoader@27d6c5e0

        ClassLoader grand = parent.getParent();
        System.out.println(grand);  // null
    }
}
```

# 2. 反射

## 2.1 反射概述
Java反射机制：是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。

## 2.2 获取Class类的对象
三种方式获取Class类型的对象：
* 使用类的class属性来获取该类对应的Class对象
* 调用对象的getClass()方法
* 使用Class类中的静态方法forName(String className)，参数的值是某个类的全路径

## 2.3 反射获取构造方法并使用
Class类中用与获取构造方法的方法：
* Constructor<?>[] getConstructors(): 返回所有**公共**构造方法对象的数组
* Constructor<?>[] getDeclaredConstructors(): 返回**所有**构造方法对象的数组
* Constructor<T> getConstructor(Class<?>...parameterTypes): 返回**单个公共**构造方法对象
* Constructor<T> getDeclaredConstructor(Class<?>...parameterTypes): 返回单个构造方法对象
* T newInstance(Object...initargs): 根据指定的构造方法创建对象

```java
public class ReflectDemo02 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // 获取Class对象
        Class<?> c = Class.forName("com.javase.myReflect.ReflectDemo.Student");

        Constructor<?>[] cons1 = c.getConstructors();
        for (Constructor<?> con1 : cons1) {
            System.out.println(con1);
        }

        System.out.println("------------");

        Constructor<?>[] cons2 = c.getDeclaredConstructors();
        for (Constructor<?> con2 : cons2) {
            System.out.println(con2);
        }

        System.out.println("------------");

        Constructor<?> con1 = c.getConstructor();
        Object obj = con1.newInstance();
        System.out.println(obj);
    }
}
```

``
基本数据类型也可以通过.class得到对应的Class类型
``

``
public void setAccesible(boolean falg): 值为true,取消访问检查
``

```java
public class ReflectTest01 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> c = Class.forName("com.javase.myReflect.ReflectDemo.Student");

        Constructor<?> con1 = c.getConstructor(String.class, int.class, String.class);  // 基本数据类型也可以通过.class得到对应的Class类型

        Object obj1 = con1.newInstance("林青霞", 30, "西安");
        System.out.println(obj1);

        System.out.println("------------");

        Constructor<?> con2 = c.getDeclaredConstructor(String.class);

//        Object obj2 = con2.newInstance("林青霞"); // 私有方法不能被new

        // 暴力反射
        con2.setAccessible(true);
        Object obj2 = con2.newInstance("林青霞");
        System.out.println(obj2);
    }
}
```

## 2.4 反射获取成员变量并使用
Class类中用与获取成员变量的方法：
* Field[] getFields(): 返回所有**公共成员变量**对象的数据
* Field[] getDeclaredFields(): 返回所有成员变量对象的数据
* Field getField(String name): 返回单个**公共成员变量**对象
* Field getDeclaredField(String name): 返回单个成员变量对象
* void set(Object obj,Object value): 给obj对象的成员变量赋值为value
```java
public class ReflectDemo03 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // 获取Class对象
        Class<?> c = Class.forName("com.javase.myReflect.ReflectDemo.Student");

        Field[] fields1=c.getFields();
        for (Field f : fields1) {
            System.out.println(f);
        }

        System.out.println("------------");

        Field[] fields2=c.getDeclaredFields();
        for (Field f : fields2) {
            System.out.println(f);
        }

        System.out.println("------------");

        Field addressField = c.getField("address");
        // 获取无参构造方法创建对象
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();
        addressField.set(obj,"西安");  // 给obj的成员变量addressField赋值为西安
        System.out.println(obj);
    }
}
```

## 2.5 反射获取成员方法并使用
Class类中用与获取成员方法的方法：
* Method[] getMethods(): 返回所有**公共成员方法**对象的数组，**包括继承的**
* Method[] getDeclaredMethods(): 返回所有成员方法对象的数组，**不包括继承的**
* Method getMethod(String name,Class<?>... parameterTypes): 返回单个公共成员方法对象
* Method getDeclaredMethod(String name,Class<?>... parameterTypes): 返回单个成员方法对象
* Object invoke(Object obj,Object... args): 调用obj对象的成员方法，参数是args，返回值是Object类型

## 2.6 反射练习
### 通过配置文件来运行类中的方法
```java
public class ReflectTest05 {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // 加载数据
        Properties prop=new Properties();
        FileReader fr=new FileReader("E:\\Workspace\\Java学习\\Javanote\\src\\com\\javase\\myReflect\\ReflectDemo\\class.txt");
        prop.load(fr);
        fr.close();
        /**
         * className=com.javase.myReflect.ReflectDemo.Student
         * methodName=study
         */
        String className = prop.getProperty("className");
        String methodName = prop.getProperty("methodName");
        // 通过反射来使用
        Class<?> c = Class.forName(className);
        
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();
        Method m = c.getMethod(methodName);
        m.invoke(obj);
    }
}
```